<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2048 游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    
    <!-- Tailwind 配置 -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        game: {
                            bg: '#faf8ef',
                            cell: '#cdc1b4',
                            empty: '#cdc1b4',
                            text: '#776e65',
                            score: '#bbada0',
                            2: '#eee4da',
                            4: '#ede0c8',
                            8: '#f2b179',
                            16: '#f59563',
                            32: '#f67c5f',
                            64: '#f65e3b',
                            128: '#edcf72',
                            256: '#edcc61',
                            512: '#edc850',
                            1024: '#edc53f',
                            2048: '#edc22e',
                            high: '#3c3a32'
                        }
                    },
                    fontFamily: {
                        game: ['"Clear Sans"', 'Helvetica Neue', 'Arial', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <!-- 自定义工具类 -->
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .game-shadow {
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }
            .tile-shadow {
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            }
            .tile-appear {
                animation: appear 0.3s ease-in-out;
            }
            .tile-merge {
                animation: merge 0.3s ease-in-out;
            }
            .tile-move {
                transition: transform 0.15s ease-in-out;
            }
        }
        
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        @keyframes merge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-game-bg font-game text-game-text min-h-screen flex flex-col items-center justify-center p-4">
    <div class="max-w-md w-full mx-auto">
        <!-- 游戏标题和分数 -->
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-[clamp(2rem,5vw,3rem)] font-bold text-game-text">2048</h1>
            
            <div class="flex gap-3">
                <!-- 分数面板 -->
                <div class="bg-game-score rounded-md px-3 py-2 min-w-[80px] text-center">
                    <div class="text-xs uppercase text-white/70 font-bold">分数</div>
                    <div id="score" class="text-xl font-bold text-white">0</div>
                </div>
                
                <!-- 最高分面板 -->
                <div class="bg-game-score rounded-md px-3 py-2 min-w-[80px] text-center">
                    <div class="text-xs uppercase text-white/70 font-bold">最高分</div>
                    <div id="highScore" class="text-xl font-bold text-white">0</div>
                </div>
            </div>
        </div>
        
        <!-- 游戏说明 -->
        <div class="mb-4 text-sm">
            <p>使用方向键移动方块，相同数字的方块相撞时会合并，并相加它们的值。尝试得到2048方块！</p>
        </div>
        
        <!-- 游戏控制按钮 -->
        <div class="flex gap-2 mb-4">
            <button id="newGameBtn" class="bg-game-score hover:bg-opacity-90 text-white py-2 px-4 rounded-md transition-colors duration-200 flex-1">
                <i class="fa fa-refresh mr-1"></i> 新游戏
            </button>
            <button id="undoBtn" class="bg-gray-300 hover:bg-gray-400 text-game-text py-2 px-4 rounded-md transition-colors duration-200">
                <i class="fa fa-undo mr-1"></i> 撤销
            </button>
        </div>
        
        <!-- 游戏容器 -->
        <div class="bg-game-cell rounded-lg p-3 game-shadow relative">
            <!-- 游戏网格 -->
            <div id="gameContainer" class="grid grid-cols-4 gap-3 aspect-square">
                <!-- 格子将通过JS动态生成 -->
            </div>
            
            <!-- 游戏结束遮罩 -->
            <div id="gameOver" class="absolute inset-0 bg-black/50 backdrop-blur-sm rounded-lg flex flex-col items-center justify-center hidden">
                <h2 class="text-3xl font-bold mb-2">游戏结束!</h2>
                <p class="text-xl mb-4">你的得分: <span id="finalScore" class="font-bold"></span></p>
                <button id="playAgainBtn" class="bg-game-score hover:bg-opacity-90 text-white py-2 px-6 rounded-md transition-colors duration-200">
                    再玩一次
                </button>
            </div>
            
            <!-- 胜利遮罩 -->
            <div id="gameWin" class="absolute inset-0 bg-black/50 backdrop-blur-sm rounded-lg flex flex-col items-center justify-center hidden">
                <h2 class="text-3xl font-bold mb-2 text-green-400">恭喜你赢了!</h2>
                <p class="text-xl mb-4">你的得分: <span id="winScore" class="font-bold"></span></p>
                <div class="flex gap-2">
                    <button id="continueBtn" class="bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-md transition-colors duration-200">
                        继续游戏
                    </button>
                    <button id="newGameWinBtn" class="bg-game-score hover:bg-opacity-90 text-white py-2 px-4 rounded-md transition-colors duration-200">
                        新游戏
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 移动设备控制按钮 -->
        <div class="mt-6 md:hidden">
            <div class="flex justify-center mb-2">
                <button id="moveUp" class="bg-gray-300 hover:bg-gray-400 text-game-text w-16 h-16 rounded-md flex items-center justify-center">
                    <i class="fa fa-arrow-up text-xl"></i>
                </button>
            </div>
            <div class="flex justify-center gap-2">
                <button id="moveLeft" class="bg-gray-300 hover:bg-gray-400 text-game-text w-16 h-16 rounded-md flex items-center justify-center">
                    <i class="fa fa-arrow-left text-xl"></i>
                </button>
                <button id="moveDown" class="bg-gray-300 hover:bg-gray-400 text-game-text w-16 h-16 rounded-md flex items-center justify-center">
                    <i class="fa fa-arrow-down text-xl"></i>
                </button>
                <button id="moveRight" class="bg-gray-300 hover:bg-gray-400 text-game-text w-16 h-16 rounded-md flex items-center justify-center">
                    <i class="fa fa-arrow-right text-xl"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // 游戏配置
            const SIZE = 4; // 4x4 网格
            const WINNING_VALUE = 2048;
            
            // 游戏状态
            let grid = [];
            let score = 0;
            let highScore = localStorage.getItem('2048-highScore') ? parseInt(localStorage.getItem('2048-highScore')) : 0;
            let gameOver = false;
            let gameWon = false;
            let history = []; // 用于撤销功能
            
            // DOM 元素
            const gameContainer = document.getElementById('gameContainer');
            const scoreElement = document.getElementById('score');
            const highScoreElement = document.getElementById('highScore');
            const gameOverElement = document.getElementById('gameOver');
            const gameWinElement = document.getElementById('gameWin');
            const finalScoreElement = document.getElementById('finalScore');
            const winScoreElement = document.getElementById('winScore');
            const newGameBtn = document.getElementById('newGameBtn');
            const playAgainBtn = document.getElementById('playAgainBtn');
            const continueBtn = document.getElementById('continueBtn');
            const newGameWinBtn = document.getElementById('newGameWinBtn');
            const undoBtn = document.getElementById('undoBtn');
            const moveUpBtn = document.getElementById('moveUp');
            const moveDownBtn = document.getElementById('moveDown');
            const moveLeftBtn = document.getElementById('moveLeft');
            const moveRightBtn = document.getElementById('moveRight');
            
            // 初始化高分
            highScoreElement.textContent = highScore;
            
            // 初始化游戏
            function initGame() {
                // 重置游戏状态
                grid = Array(SIZE).fill().map(() => Array(SIZE).fill(0));
                score = 0;
                gameOver = false;
                gameWon = false;
                history = [];
                
                // 更新分数显示
                scoreElement.textContent = score;
                
                // 隐藏游戏结束和胜利界面
                gameOverElement.classList.add('hidden');
                gameWinElement.classList.add('hidden');
                
                // 生成初始方块
                addNewTile();
                addNewTile();
                
                // 渲染网格
                renderGrid();
            }
            
            // 渲染网格
            function renderGrid() {
                // 清空游戏容器
                gameContainer.innerHTML = '';
                
                // 渲染每个格子
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const value = grid[y][x];
                        const cell = document.createElement('div');
                        
                        // 基础样式
                        cell.className = 'rounded-md flex items-center justify-center bg-game-empty transition-all duration-200';
                        
                        // 如果有值，添加相应的样式和文本
                        if (value !== 0) {
                            // 根据值设置背景颜色
                            cell.classList.add(`bg-game-${value}`);
                            
                            // 根据值大小设置文本大小
                            if (value >= 1024) {
                                cell.classList.add('text-[1.1rem]');
                            } else if (value >= 128) {
                                cell.classList.add('text-[1.3rem]');
                            } else {
                                cell.classList.add('text-[1.5rem]');
                            }
                            
                            // 设置文本颜色和粗细
                            cell.classList.add('font-bold');
                            if (value <= 4) {
                                cell.classList.add('text-game-text');
                            } else {
                                cell.classList.add('text-white');
                            }
                            
                            // 添加方块值
                            cell.textContent = value;
                            
                            // 添加动画效果
                            cell.classList.add('tile-shadow', 'tile-appear');
                        }
                        
                        // 添加到游戏容器
                        gameContainer.appendChild(cell);
                    }
                }
            }
            
            // 在随机空位置添加新方块（2或4）
            function addNewTile() {
                // 收集所有空位置
                const emptyCells = [];
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (grid[y][x] === 0) {
                            emptyCells.push({ x, y });
                        }
                    }
                }
                
                // 如果没有空位置，返回 false
                if (emptyCells.length === 0) {
                    return false;
                }
                
                // 随机选择一个空位置
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                
                // 90% 概率生成 2，10% 概率生成 4
                grid[randomCell.y][randomCell.x] = Math.random() < 0.9 ? 2 : 4;
                
                return true;
            }
            
            // 保存当前游戏状态到历史记录
            function saveState() {
                // 深拷贝当前网格和分数
                const gridCopy = JSON.parse(JSON.stringify(grid));
                history.push({
                    grid: gridCopy,
                    score: score
                });
                
                // 限制历史记录长度
                if (history.length > 10) {
                    history.shift();
                }
            }
            
            // 撤销上一步
            function undoMove() {
                if (history.length === 0) return;
                
                const lastState = history.pop();
                grid = lastState.grid;
                score = lastState.score;
                
                // 更新分数显示
                scoreElement.textContent = score;
                
                // 渲染网格
                renderGrid();
                
                // 重新检查游戏状态
                gameOver = false;
                gameOverElement.classList.add('hidden');
            }
            
            // 移动方块（上）
            function moveUp() {
                saveState();
                let moved = false;
                
                for (let x = 0; x < SIZE; x++) {
                    // 处理每一列
                    for (let y = 1; y < SIZE; y++) {
                        if (grid[y][x] !== 0) {
                            let newY = y;
                            
                            // 找到可以移动到的位置
                            while (newY > 0 && grid[newY - 1][x] === 0) {
                                newY--;
                                moved = true;
                            }
                            
                            // 检查是否可以合并
                            if (newY > 0 && grid[newY - 1][x] === grid[y][x]) {
                                // 合并方块
                                grid[newY - 1][x] *= 2;
                                
                                // 更新分数
                                score += grid[newY - 1][x];
                                scoreElement.textContent = score;
                                
                                // 检查是否超过最高分
                                if (score > highScore) {
                                    highScore = score;
                                    highScoreElement.textContent = highScore;
                                    localStorage.setItem('2048-highScore', highScore);
                                }
                                
                                // 检查是否获胜
                                if (grid[newY - 1][x] === WINNING_VALUE && !gameWon) {
                                    gameWon = true;
                                    winScoreElement.textContent = score;
                                    gameWinElement.classList.remove('hidden');
                                }
                                
                                grid[y][x] = 0;
                                moved = true;
                            } else if (newY !== y) {
                                // 只是移动，不合并
                                grid[newY][x] = grid[y][x];
                                grid[y][x] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                // 如果有移动，添加新方块并重新渲染
                if (moved) {
                    addNewTile();
                    renderGrid();
                    
                    // 检查游戏是否结束
                    if (!canMove() && !gameWon) {
                        gameOver = true;
                        finalScoreElement.textContent = score;
                        gameOverElement.classList.remove('hidden');
                    }
                }
            }
            
            // 移动方块（下）
            function moveDown() {
                saveState();
                let moved = false;
                
                for (let x = 0; x < SIZE; x++) {
                    // 处理每一列，从下往上
                    for (let y = SIZE - 2; y >= 0; y--) {
                        if (grid[y][x] !== 0) {
                            let newY = y;
                            
                            // 找到可以移动到的位置
                            while (newY < SIZE - 1 && grid[newY + 1][x] === 0) {
                                newY++;
                                moved = true;
                            }
                            
                            // 检查是否可以合并
                            if (newY < SIZE - 1 && grid[newY + 1][x] === grid[y][x]) {
                                // 合并方块
                                grid[newY + 1][x] *= 2;
                                
                                // 更新分数
                                score += grid[newY + 1][x];
                                scoreElement.textContent = score;
                                
                                // 检查是否超过最高分
                                if (score > highScore) {
                                    highScore = score;
                                    highScoreElement.textContent = highScore;
                                    localStorage.setItem('2048-highScore', highScore);
                                }
                                
                                // 检查是否获胜
                                if (grid[newY + 1][x] === WINNING_VALUE && !gameWon) {
                                    gameWon = true;
                                    winScoreElement.textContent = score;
                                    gameWinElement.classList.remove('hidden');
                                }
                                
                                grid[y][x] = 0;
                                moved = true;
                            } else if (newY !== y) {
                                // 只是移动，不合并
                                grid[newY][x] = grid[y][x];
                                grid[y][x] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                // 如果有移动，添加新方块并重新渲染
                if (moved) {
                    addNewTile();
                    renderGrid();
                    
                    // 检查游戏是否结束
                    if (!canMove() && !gameWon) {
                        gameOver = true;
                        finalScoreElement.textContent = score;
                        gameOverElement.classList.remove('hidden');
                    }
                }
            }
            
            // 移动方块（左）
            function moveLeft() {
                saveState();
                let moved = false;
                
                for (let y = 0; y < SIZE; y++) {
                    // 处理每一行
                    for (let x = 1; x < SIZE; x++) {
                        if (grid[y][x] !== 0) {
                            let newX = x;
                            
                            // 找到可以移动到的位置
                            while (newX > 0 && grid[y][newX - 1] === 0) {
                                newX--;
                                moved = true;
                            }
                            
                            // 检查是否可以合并
                            if (newX > 0 && grid[y][newX - 1] === grid[y][x]) {
                                // 合并方块
                                grid[y][newX - 1] *= 2;
                                
                                // 更新分数
                                score += grid[y][newX - 1];
                                scoreElement.textContent = score;
                                
                                // 检查是否超过最高分
                                if (score > highScore) {
                                    highScore = score;
                                    highScoreElement.textContent = highScore;
                                    localStorage.setItem('2048-highScore', highScore);
                                }
                                
                                // 检查是否获胜
                                if (grid[y][newX - 1] === WINNING_VALUE && !gameWon) {
                                    gameWon = true;
                                    winScoreElement.textContent = score;
                                    gameWinElement.classList.remove('hidden');
                                }
                                
                                grid[y][x] = 0;
                                moved = true;
                            } else if (newX !== x) {
                                // 只是移动，不合并
                                grid[y][newX] = grid[y][x];
                                grid[y][x] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                // 如果有移动，添加新方块并重新渲染
                if (moved) {
                    addNewTile();
                    renderGrid();
                    
                    // 检查游戏是否结束
                    if (!canMove() && !gameWon) {
                        gameOver = true;
                        finalScoreElement.textContent = score;
                        gameOverElement.classList.remove('hidden');
                    }
                }
            }
            
            // 移动方块（右）
            function moveRight() {
                saveState();
                let moved = false;
                
                for (let y = 0; y < SIZE; y++) {
                    // 处理每一行，从右往左
                    for (let x = SIZE - 2; x >= 0; x--) {
                        if (grid[y][x] !== 0) {
                            let newX = x;
                            
                            // 找到可以移动到的位置
                            while (newX < SIZE - 1 && grid[y][newX + 1] === 0) {
                                newX++;
                                moved = true;
                            }
                            
                            // 检查是否可以合并
                            if (newX < SIZE - 1 && grid[y][newX + 1] === grid[y][x]) {
                                // 合并方块
                                grid[y][newX + 1] *= 2;
                                
                                // 更新分数
                                score += grid[y][newX + 1];
                                scoreElement.textContent = score;
                                
                                // 检查是否超过最高分
                                if (score > highScore) {
                                    highScore = score;
                                    highScoreElement.textContent = highScore;
                                    localStorage.setItem('2048-highScore', highScore);
                                }
                                
                                // 检查是否获胜
                                if (grid[y][newX + 1] === WINNING_VALUE && !gameWon) {
                                    gameWon = true;
                                    winScoreElement.textContent = score;
                                    gameWinElement.classList.remove('hidden');
                                }
                                
                                grid[y][x] = 0;
                                moved = true;
                            } else if (newX !== x) {
                                // 只是移动，不合并
                                grid[y][newX] = grid[y][x];
                                grid[y][x] = 0;
                                moved = true;
                            }
                        }
                    }
                }
                
                // 如果有移动，添加新方块并重新渲染
                if (moved) {
                    addNewTile();
                    renderGrid();
                    
                    // 检查游戏是否结束
                    if (!canMove() && !gameWon) {
                        gameOver = true;
                        finalScoreElement.textContent = score;
                        gameOverElement.classList.remove('hidden');
                    }
                }
            }
            
            // 检查是否还有可能的移动
            function canMove() {
                // 检查是否有空位置
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (grid[y][x] === 0) {
                            return true;
                        }
                    }
                }
                
                // 检查是否有可以合并的方块
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        // 检查右侧
                        if (x < SIZE - 1 && grid[y][x] === grid[y][x + 1]) {
                            return true;
                        }
                        // 检查下方
                        if (y < SIZE - 1 && grid[y][x] === grid[y + 1][x]) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // 事件监听 - 键盘控制
            document.addEventListener('keydown', (e) => {
                // 如果游戏结束或胜利，只有按空格键可以重新开始
                if (gameOver || gameWon) {
                    if (e.key === ' ') {
                        initGame();
                    }
                    return;
                }
                
                // 阻止方向键滚动页面
                if ([37, 38, 39, 40].includes(e.keyCode)) {
                    e.preventDefault();
                }
                
                // 根据方向键移动方块
                switch (e.key) {
                    case 'ArrowUp':
                        moveUp();
                        break;
                    case 'ArrowDown':
                        moveDown();
                        break;
                    case 'ArrowLeft':
                        moveLeft();
                        break;
                    case 'ArrowRight':
                        moveRight();
                        break;
                    case 'z':
                        // Ctrl+Z 撤销
                        if (e.ctrlKey || e.metaKey) {
                            e.preventDefault();
                            undoMove();
                        }
                        break;
                }
            });
            
            // 事件监听 - 按钮控制
            newGameBtn.addEventListener('click', initGame);
            playAgainBtn.addEventListener('click', initGame);
            newGameWinBtn.addEventListener('click', initGame);
            undoBtn.addEventListener('click', undoMove);
            
            // 继续游戏（忽略胜利状态）
            continueBtn.addEventListener('click', () => {
                gameWinElement.classList.add('hidden');
            });
            
            // 移动设备控制按钮
            moveUpBtn.addEventListener('click', moveUp);
            moveDownBtn.addEventListener('click', moveDown);
            moveLeftBtn.addEventListener('click', moveLeft);
            moveRightBtn.addEventListener('click', moveRight);
            
            // 触摸滑动支持
            let touchStartX = 0;
            let touchStartY = 0;
            
            gameContainer.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }, false);
            
            gameContainer.addEventListener('touchend', (e) => {
                if (gameOver || gameWon) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchEndY = e.changedTouches[0].clientY;
                
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                
                // 确定滑动方向（优先考虑距离长的方向）
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // 水平滑动
                    if (Math.abs(diffX) > 20) { // 最小滑动距离
                        if (diffX > 0) {
                            moveRight();
                        } else {
                            moveLeft();
                        }
                    }
                } else {
                    // 垂直滑动
                    if (Math.abs(diffY) > 20) { // 最小滑动距离
                        if (diffY > 0) {
                            moveDown();
                        } else {
                            moveUp();
                        }
                    }
                }
            }, false);
            
            // 开始游戏
            initGame();
        });
    </script>
</body>
</html>
    
